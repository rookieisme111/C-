1. **简单介绍一下你的项目**
> 我做的是一个简单的web服务器，主要采用了IO复用中的epoll+非阻塞IO进行IO事件的处理，为实现高并发的目的采用了半同步/半反应堆的并发模型，多线程方面采用了线程池技术，减少频繁创建线程的开销；增加了定时清理不活跃连接的功能；最后客户请求处理方面实现了简单HTTP的解析和应答功能。
2. **最有技术含量的部分**

3. **讲一讲reactor和proactor的区别**
> 主要的区别在于IO读写是由谁完成的
> reactor:主线程只负责监听所有的连接，主线程负责将触发的IO事件插入到请求队列中，由工作线程来完成IO读写，接受连接，处理客户请求等具体的操作。一般使用同步IO
> proactor:工作线程只负责处理逻辑业务，其余的IO读写和接受连接等事务都由主线程或者内核来操作完成。一般使用异步IO来实现，也可以使用同步IO来模仿proactor

> 以读操作为例（类操作类似）。在Reactor中实现读：- 注册读就绪事件和相应的事件处理器- 事件分离器等待事件- 事件到来，激活分离器，分离器调用事件对应的处理器。- 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。在Proactor中实现读：- 处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。- 事件分离器等待操作完成事件- 在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。- 事件分离器呼唤处理器。- 事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器

4. **同步和异步的区别，阻塞和非阻塞的区别**
> 同步IO指的是，内核通知应用程序的是IO的就绪事件，具体的IO操作需要应用程序自己完成；异步相反，内核通知应用程序的是IO完成事件，此时IO操作已经由内核完成。

> 阻塞和非阻塞：阻塞调用，指如果调用中涉及到的某个事件还未发生，那么会一直等待，如果没有超时措施将一直等待；非阻塞，指的是不管调用涉及到的事件是否发生，都会直接返回，通过错误码来反应失败的原因。

5. **什么是有限状态机？如何使用有限状态机来处理http请求**

6. **epoll的原理，和其它IO复用的区别**
> epoll是是一种IO复用的模型，它通在内核中维持一张事件表，将连接socket(io文件描述符)上感兴趣的读写事件注册到事件表中，每次调用epoll_wait时都会把已发生的事件传递给应用程序，使得应用程序可以非阻塞的进行IO。

> 1. 采用了内核事件表，每次启动监听时，不需要由参数传入感兴趣的文件描述符及事件的集合，减少了数据从用户空间拷贝到内核空间的开销
> 2. epoll和poll没有文件描述符数量的限制（能达到系统允许打开的文件描述符最大数量），select有限制1024
> 3. epoll有独特的ET工作模式，提升了效率
> 4. epoll用一个空的数据结构保存就绪的事件，而poll和select则在传入的参数上进行修改，这种形式同样影响了索引就绪事件的效率
> 5. 从实现讲，select和poll采用了轮询方式，每次系统调用时，都要对整个注册的文件描述符集合进行扫描，并将其中就绪的文件描述符返回给用户；epoll采用了回调模式，内核监测到有就绪的文件描述符时，触发回调函数，函数将就是事件插入内核的就绪事件队列中。当活动连接较多时，三者的效率差不多，epoll适合连接数量多，活动连接少的情况。

7. **什么是IO多路复用**
> 本质上是一种通知机制，将就绪事件通知应用程序，这样程序就可以非阻塞的进行读写操作，而不需要采用阻塞等待，或非阻塞轮询的方式，将一个线程的资源全部霸占。

8. **你的定时器是如何实现的**
> 每个客户连接在创建时，都会绑定一个定时器，并设置定时时间，通过一个升序链表来组织这些定时器，当一个定时周期到来时，会监测升序链表中是否有不活跃的客户连接，将不活跃的客户连接断开连接并且进行清理工作，然后重新设立定时；当客户连接上发生读写事件时，会更新对应定时器的，并且调整在升序链表中的位置。

9. **边沿触发ET和水平触发LT的区别，为什么采用ET的效率更加高**
> 边沿触发；当epoll_wait检测到fd上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件
> 水平触发：当epoll_wait检测到fd上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件，这样，当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通知此事件，直到此事件被处理。

> epoll调用可以大大减少同一个epoll事件被反复触发的次数，所以提高了效率。

10. **如何进行压测**

11. **你觉得哪部分会称为性能瓶颈**

12. **你的改进措施是什么**
