# **一些重要的关键字和C++语言特性**

1. 左值和右值？左值引用和右值引用
> 左值：是表达式结束后可以存在的持久化对象，可以取地址，是具名的变量或对象
> 右值：是表达式结束后即销毁的临时对象，不可以取地址，没有名字，字面值，表达式的值，返回值是临时变量

2. std::move函数
> 作用：将一个左值强制转换为一个右值，以支持移动语义

> move是一个模板函数，参数为T&&是一个通用引用，传入左值就是左值引用，传入右值就是右值引用。使用remove_reference类内type得到原始类型，然后使用static_cast<>转换为该类型的右值引用。

3. 野指针和悬空指针
> 野指针是指定义后未经初始化的指针，其指向未知的内存区域。悬空指针是原先指向的内存被释放后指针。两类指针都是具有危害的，访问“不安全可控”的内存区域，会导致未知的行为。

4. 指针和引用的区别
> 引用的底层实现是指针常量，所以可以转换为普通指针和常量指针的区别
> 1.指针可以改变指向，引用不能改变绑定的对象。 2.指针定义后可以不初始化，引用定义必须绑定对象。 3.指针可以多级嵌套，引用只有一层。

> 相同点：占用4个字节

5. 强制类型转换
https://zhuanlan.zhihu.com/p/258975506
> dynamic_cast<>和static_cast<>都可以执行类层次间，基类和派生类指针间的类型转换，不同点是前者会在运行时执行类型检查，这种检查在上行转换时没有区别，都是安全的，在执行下行转换时，前者是安全的，前提是类必须含有虚函数，如果检查出是不安全的，则转换后的指针为0。

6. 模板：函数模板和类模板

> 函数模板类型
> ```
> template <模板参数列表 class T>
> T& fun(T& a, T& b);
> ```
> 函数模板调用时是隐式调用的，不需要指定模板的参数类型（显示+隐式），由编译器自动类型推导，当编译器无法识别一个表达式是一个成员变量还是类型，如果是类型需要显示用关键字typename指明

> 类模板
> ```
> template <class T1, class T2>
> class A{
> };
> ```
> 在使用类模板时，必须显示给出模板参数列表，类模板可以全特化和偏特化

7. 模板为什么要特化？
> 模板特化分为全特化和偏特化，全特化是指把模板参数全部限定，偏特化是指将一部分模板参数限定。模板需要特化的情况是，则一些特定的模板参数下，模板有更好的实现方法。

8. 类型萃取
> 类型萃取：是利用模板技术来萃取类型（包括内置类型和自定义类型）的某些特性，用以判断该类型是否具有某些特性，从而在泛型编程中进行特殊处理以提高效率。

# **一些重要的关键字**
1. strlen和sizeof的区别
> strlen是库函数，sizeof是关键字；strlen用于获得字符数组的长度，到\0为止的长度，sizeof用于获取变量或类型的占用的字节数；strlen在运行时计算长度，sizeof在编译时计算长度

2. explicit关键字的作用
> 禁止隐式的类型转换
> ```
> A a(10); //显式的调用了构造函数
> A a = 10; //隐式的调用了构造函数
> 如果用explicit修饰了对应构造函数，那么第二个语句就会出错，并且在函数参数处，需要某种类型的参数，而使用了另外的类型的实参，如果有对应构造函数，则会隐式调用构造
> ```

3. static关键字的作用
> 静态全局变量、静态局部变量、静态函数、静态类成员变量、静态类成员函数
> static关键字对变量的影响体现在生命周期和作用域：

> 生命周期：从定义该变量开始，到整个程序结束为止   作用域：全局变量被修饰后，其作用域为文件作用域，即定义它的文件内；局部变量被修饰后，作用域为局部作用域，为定义它函数块内，并且只需一次初始化；类成员变量被修饰后，成为该类所有对象所共享的变量，也只需一次初始化，在类外完成初始化，不占用对象内存，可以通过对象和类名进行访问。

> static关键字修饰函数时，外部的静态函数的作用域为文件作用域，文件外不可见；静态类成员函数，属于类，为所有对象共享，类内静态函数内只能使用类的静态成员，不能使用非静态的成员，因为没有隐式的传递this指针。
