# **查找算法，查找的算法总是和数据结构的类型紧密相关的**

1. 顺序查找
> 顺序查找是最朴素的查找方式，需要完整的遍历一遍所有数据才能确定查找结果，存储的数据结果可以是数组或者链表。
> 时间复杂度为O(n)

2. 二分查找
> 二分查找要求数据必须是有序排列的，每次取中间位置的数据和查找值进行比较，如果相对，则查找成功，如果大于，则在前半区域继续查找；如果小于，则在后半区域继续查找。
> 时间复杂度O(nlogn)

3. 二叉查找树BST
> BST的定义：1）左子树不空，根节点的值大于左子树的上所有节点的值 2）右子树不空，根节点的值小于右子树上所有节点的值 3）并且左右子树都是BST
> 其时间复杂度和BST的结构相关

4. 哈希表（散列表）
> 哈希表是使用哈希函数组织数据，支持快速插入和查找的数据结构
> C++中unordered_set和unordered_map的底层实现是哈希表，而map和set的底层实现是红黑树

5. 分块查找
> 将n个数据分为m个块数据，满足块间有序，块内无序。块间有序：后一块所有数据大于前一块的最大值
> 然后分别使用二分查找和顺序查找

6. 平衡二叉树AVL
> 平衡二叉树首先是一个二叉搜索树，其次二叉树中所有节点的左右子树的高度差不超过1
> 二叉平衡树考察插入和删除节点时，如何调整AVL

7. B-树（B树）/B+树 https://www.jianshu.com/p/ace3cd6526c4
> B-树：是一颗多路自平衡搜索树，B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中
> 特性：
> 1. 每个节点都有两个及以上的子节点，不是二叉树，而是一颗n叉树
> 2. 索引值和数据域的值存放在一起，且分布于整棵树
> 3. 搜索可能在非叶节点结束

> B+树：是对B-树的变体
> 特性；
> 1. 所有的键值对都存储在叶节点中，内部节点有关键字，但没有数据域的值
> 2. 非叶节点中增加了链指针

> **B-树和B+树的区别**
> 1. 查找的时间复杂度，B+树的内部节点不存储数据，所有数据域的值都在叶节点中，所以查找的时间复杂度固定为O(logn)，而B-树由于它的键值对散布于整棵树，所以它的时间复杂度在O(1)和O(logn)之间
> 2. B+树比B-树更适合外部存储器，因为B+树的内节点中没有data域的值，所以同样节点大小的两种树的节点，B+树节点可以存下更多的索引信息，从而提供更大范围更精准的查找。
> 3. B+树的叶节点两两相连，可以支持快速的范围查询，B—树则不支持；B+树很好的利用了局部性原理，key接近的值可能在不久的将来也会使用，通过磁盘预读功能，可以减少磁盘的IO次数

8. 红黑树 RBT
> 红黑树：是一颗近似平衡的二叉搜索树，除了满足二叉搜索树的要求外，还有一些颜色上的要求
> **红黑树的定义：**
> 1. 每个结点必须有颜色，要么是黑色，要么是红色
> 2. 根节点是黑色的
> 3. 红结点的两个孩子结点都是黑色的（红节点无红孩子）
> 4. 叶结点都是黑色的
> 5. 所有结点，到其后辈叶结点的所有简单路径上，经过的黒结点的数量是相同的

> 红黑树的插入和删除除了常规的BST的操作外，还需要进行额外的着色，使其符合红黑树的定义
